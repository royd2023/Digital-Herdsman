# Digital Herdsman Farmer-Side MVP ‚Äî Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build the farmer-side inventory management app ‚Äî auth, product type management, add-item workflow with QR label generation and sharing, and inventory dashboard.

**Architecture:** Next.js 14 App Router (mobile-first) backed by Supabase (Postgres + Auth + Storage). Business logic lives in a `/lib` layer of pure TypeScript with no Next.js dependencies, enabling future migration to React Native. UI is Tailwind CSS, mobile-first throughout.

**Tech Stack:** Next.js 14, TypeScript, Tailwind CSS, Supabase (Auth + Postgres + Storage), Prisma, `qrcode` npm package, `html2canvas` for label image export, Vercel for hosting.

---

## Task 1: Project Scaffold

**Files:**
- Create: `package.json`, `tsconfig.json`, `tailwind.config.ts`, `next.config.ts` (auto-generated by scaffold)
- Create: `.env.local` (from `.env.example`)

**Step 1: Scaffold Next.js project**

```bash
npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*" --no-git
```

Expected: Project files created in current directory.

**Step 2: Install additional dependencies**

```bash
npm install @supabase/supabase-js @supabase/ssr prisma @prisma/client qrcode html2canvas
npm install -D @types/qrcode
```

**Step 3: Create `.env.example`**

```
NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
DATABASE_URL=your-supabase-postgres-connection-string
DIRECT_URL=your-supabase-direct-connection-string
```

Copy to `.env.local` and fill in values from your Supabase project dashboard.

**Step 4: Verify dev server starts**

```bash
npm run dev
```

Expected: `ready - started server on 0.0.0.0:3000`

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: scaffold Next.js project with Supabase and Tailwind"
```

---

## Task 2: Supabase Setup & Database Schema

**Files:**
- Create: `prisma/schema.prisma`
- Create: `src/lib/supabase/client.ts`
- Create: `src/lib/supabase/server.ts`
- Create: `src/lib/supabase/middleware.ts`

**Step 1: Initialise Prisma**

```bash
npx prisma init --datasource-provider postgresql
```

**Step 2: Write `prisma/schema.prisma`**

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Category {
  beef
  pork
  chicken
  lamb
  fish
  eggs
  dairy
  honey
  preserves
  vegetables
  fruit
  other
}

enum PricingMode {
  per_weight
  fixed
}

enum ItemStatus {
  available
  sold
  reserved
}

model Farm {
  id         String        @id @default(uuid())
  name       String
  ownerId    String        @map("owner_id")
  createdAt  DateTime      @default(now()) @map("created_at")
  products   ProductType[]
  items      InventoryItem[]

  @@map("farms")
}

model ProductType {
  id          String        @id @default(uuid())
  farmId      String        @map("farm_id")
  name        String
  category    Category
  pricingMode PricingMode   @map("pricing_mode")
  price       Decimal       @db.Decimal(10, 2)
  unit        String
  archived    Boolean       @default(false)
  farm        Farm          @relation(fields: [farmId], references: [id])
  items       InventoryItem[]

  @@map("product_types")
}

model InventoryItem {
  id            String      @id @default(uuid())
  farmId        String      @map("farm_id")
  productTypeId String      @map("product_type_id")
  weight        Decimal?    @db.Decimal(10, 3)
  price         Decimal     @db.Decimal(10, 2)
  status        ItemStatus  @default(available)
  qrCodeUrl     String?     @map("qr_code_url")
  createdAt     DateTime    @default(now()) @map("created_at")
  farm          Farm        @relation(fields: [farmId], references: [id])
  productType   ProductType @relation(fields: [productTypeId], references: [id])

  @@map("inventory_items")
}
```

**Step 3: Push schema to Supabase**

```bash
npx prisma db push
```

Expected: Tables created in Supabase Postgres.

**Step 4: Generate Prisma client**

```bash
npx prisma generate
```

**Step 5: Create `src/lib/supabase/client.ts`**

```typescript
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

**Step 6: Create `src/lib/supabase/server.ts`**

```typescript
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return cookieStore.getAll() },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {}
        },
      },
    }
  )
}
```

**Step 7: Create `src/middleware.ts`**

```typescript
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return request.cookies.getAll() },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({ request })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  const { data: { user } } = await supabase.auth.getUser()

  const isAuthRoute = request.nextUrl.pathname.startsWith('/login')
  const isPublicRoute = request.nextUrl.pathname === '/'

  if (!user && !isAuthRoute && !isPublicRoute) {
    return NextResponse.redirect(new URL('/login', request.url))
  }

  if (user && isAuthRoute) {
    return NextResponse.redirect(new URL('/dashboard', request.url))
  }

  return supabaseResponse
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'],
}
```

**Step 8: Commit**

```bash
git add -A
git commit -m "feat: add Supabase clients, Prisma schema, and auth middleware"
```

---

## Task 3: Lib Layer ‚Äî Pricing & QR

**Files:**
- Create: `src/lib/pricing.ts`
- Create: `src/lib/pricing.test.ts`
- Create: `src/lib/qr.ts`
- Create: `src/lib/label.ts`

**Step 1: Write failing tests for pricing**

Create `src/lib/pricing.test.ts`:

```typescript
import { calculatePrice } from './pricing'

describe('calculatePrice', () => {
  it('calculates per-weight price correctly', () => {
    expect(calculatePrice({ pricingMode: 'per_weight', pricePerUnit: 15.99, weight: 1.5 }))
      .toBe(23.99)
  })

  it('rounds to 2 decimal places', () => {
    expect(calculatePrice({ pricingMode: 'per_weight', pricePerUnit: 10, weight: 0.333 }))
      .toBe(3.33)
  })

  it('returns fixed price when pricing mode is fixed', () => {
    expect(calculatePrice({ pricingMode: 'fixed', pricePerUnit: 6.50, weight: null }))
      .toBe(6.50)
  })

  it('throws if per_weight is missing weight', () => {
    expect(() => calculatePrice({ pricingMode: 'per_weight', pricePerUnit: 10, weight: null }))
      .toThrow('Weight required for per_weight pricing')
  })
})
```

**Step 2: Run tests to verify they fail**

```bash
npx jest src/lib/pricing.test.ts
```

Expected: FAIL ‚Äî `calculatePrice` not found.

**Step 3: Install Jest**

```bash
npm install -D jest @types/jest ts-jest jest-environment-node
```

Add to `package.json`:
```json
"jest": {
  "preset": "ts-jest",
  "testEnvironment": "node",
  "moduleNameMapper": { "^@/(.*)$": "<rootDir>/src/$1" }
},
"scripts": {
  "test": "jest"
}
```

**Step 4: Write `src/lib/pricing.ts`**

```typescript
type PricingInput = {
  pricingMode: 'per_weight' | 'fixed'
  pricePerUnit: number
  weight: number | null
}

export function calculatePrice({ pricingMode, pricePerUnit, weight }: PricingInput): number {
  if (pricingMode === 'fixed') return pricePerUnit
  if (weight === null) throw new Error('Weight required for per_weight pricing')
  return Math.round(pricePerUnit * weight * 100) / 100
}
```

**Step 5: Run tests to verify they pass**

```bash
npx jest src/lib/pricing.test.ts
```

Expected: PASS ‚Äî 4 tests.

**Step 6: Write `src/lib/qr.ts`**

```typescript
import QRCode from 'qrcode'

export async function generateQRDataUrl(itemId: string, baseUrl: string): Promise<string> {
  const url = `${baseUrl}/item/${itemId}`
  return QRCode.toDataURL(url, { width: 300, margin: 2 })
}
```

**Step 7: Write `src/lib/label.ts`**

```typescript
export type LabelData = {
  farmName: string
  productName: string
  weight: number | null
  unit: string
  price: number
  qrDataUrl: string
  itemId: string
}

export function formatLabelPrice(price: number): string {
  return `$${price.toFixed(2)}`
}

export function formatLabelWeight(weight: number | null, unit: string): string | null {
  if (weight === null) return null
  return `${weight.toFixed(3)} ${unit}`
}
```

**Step 8: Commit**

```bash
git add -A
git commit -m "feat: add pricing, QR, and label lib utilities with tests"
```

---

## Task 4: Auth ‚Äî Login Page

**Files:**
- Create: `src/app/login/page.tsx`
- Create: `src/app/login/actions.ts`
- Modify: `src/app/globals.css`

**Step 1: Write `src/app/login/actions.ts`**

```typescript
'use server'

import { revalidatePath } from 'next/cache'
import { redirect } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'

export async function login(formData: FormData) {
  const supabase = await createClient()
  const { error } = await supabase.auth.signInWithPassword({
    email: formData.get('email') as string,
    password: formData.get('password') as string,
  })
  if (error) return { error: error.message }
  revalidatePath('/', 'layout')
  redirect('/dashboard')
}

export async function logout() {
  const supabase = await createClient()
  await supabase.auth.signOut()
  redirect('/login')
}
```

**Step 2: Write `src/app/login/page.tsx`**

```typescript
import { login } from './actions'

export default function LoginPage() {
  return (
    <main className="min-h-screen flex items-center justify-center bg-stone-50 px-4">
      <div className="w-full max-w-sm">
        <h1 className="text-2xl font-bold text-stone-800 mb-2">Digital Herdsman</h1>
        <p className="text-stone-500 mb-8 text-sm">Farm inventory management</p>
        <form className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-stone-700 mb-1" htmlFor="email">
              Email
            </label>
            <input
              id="email"
              name="email"
              type="email"
              required
              className="w-full px-3 py-2.5 border border-stone-300 rounded-lg text-stone-900 focus:outline-none focus:ring-2 focus:ring-green-600"
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-stone-700 mb-1" htmlFor="password">
              Password
            </label>
            <input
              id="password"
              name="password"
              type="password"
              required
              className="w-full px-3 py-2.5 border border-stone-300 rounded-lg text-stone-900 focus:outline-none focus:ring-2 focus:ring-green-600"
            />
          </div>
          <button
            formAction={login}
            className="w-full py-3 bg-green-700 text-white font-medium rounded-lg hover:bg-green-800 active:bg-green-900 transition-colors"
          >
            Sign in
          </button>
        </form>
      </div>
    </main>
  )
}
```

**Step 3: Manually test in browser**

- Visit `http://localhost:3000/login`
- Verify form renders correctly on mobile viewport (375px wide)
- Sign in with a test Supabase user (create one in Supabase Auth dashboard)
- Verify redirect to `/dashboard` after login

**Step 4: Commit**

```bash
git add -A
git commit -m "feat: add login page with Supabase auth"
```

---

## Task 5: Farm Setup ‚Äî Server Actions & Prisma Client

**Files:**
- Create: `src/lib/db.ts`
- Create: `src/lib/farm.ts`
- Create: `src/app/onboarding/page.tsx`
- Create: `src/app/onboarding/actions.ts`

**Step 1: Create `src/lib/db.ts`**

```typescript
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as { prisma: PrismaClient }

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
```

**Step 2: Create `src/lib/farm.ts`**

```typescript
import { prisma } from './db'

export async function getFarmByOwner(ownerId: string) {
  return prisma.farm.findFirst({ where: { ownerId } })
}

export async function createFarm(ownerId: string, name: string) {
  return prisma.farm.create({ data: { ownerId, name } })
}
```

**Step 3: Create `src/app/onboarding/actions.ts`**

```typescript
'use server'

import { redirect } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'
import { createFarm } from '@/lib/farm'

export async function setupFarm(formData: FormData) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) redirect('/login')

  await createFarm(user.id, formData.get('name') as string)
  redirect('/dashboard')
}
```

**Step 4: Create `src/app/onboarding/page.tsx`**

```typescript
import { setupFarm } from './actions'

export default function OnboardingPage() {
  return (
    <main className="min-h-screen flex items-center justify-center bg-stone-50 px-4">
      <div className="w-full max-w-sm">
        <h1 className="text-xl font-bold text-stone-800 mb-2">Set up your farm</h1>
        <p className="text-stone-500 text-sm mb-6">What's your farm called?</p>
        <form className="space-y-4">
          <input
            name="name"
            type="text"
            placeholder="e.g. Johnson Family Farm"
            required
            className="w-full px-3 py-2.5 border border-stone-300 rounded-lg text-stone-900 focus:outline-none focus:ring-2 focus:ring-green-600"
          />
          <button
            formAction={setupFarm}
            className="w-full py-3 bg-green-700 text-white font-medium rounded-lg hover:bg-green-800 transition-colors"
          >
            Create farm
          </button>
        </form>
      </div>
    </main>
  )
}
```

**Step 5: Update middleware to handle onboarding**

In `src/middleware.ts`, add onboarding redirect logic after auth check:

```typescript
// After confirming user is logged in, check if they have a farm
// (This is handled in the dashboard layout ‚Äî middleware stays lean)
```

Note: Farm existence check is handled in the dashboard layout (Task 6), not middleware. Keep middleware focused on auth only.

**Step 6: Commit**

```bash
git add -A
git commit -m "feat: add farm onboarding page and Prisma db client"
```

---

## Task 6: Dashboard Layout & Page

**Files:**
- Create: `src/app/(app)/layout.tsx`
- Create: `src/app/(app)/dashboard/page.tsx`
- Create: `src/components/BottomNav.tsx`

**Step 1: Create `src/app/(app)/layout.tsx`**

This layout wraps all authenticated app pages. It checks for a farm and redirects to onboarding if none exists.

```typescript
import { redirect } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'
import { getFarmByOwner } from '@/lib/farm'
import BottomNav from '@/components/BottomNav'

export default async function AppLayout({ children }: { children: React.ReactNode }) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) redirect('/login')

  const farm = await getFarmByOwner(user.id)
  if (!farm) redirect('/onboarding')

  return (
    <div className="min-h-screen bg-stone-50 pb-20">
      {children}
      <BottomNav />
    </div>
  )
}
```

**Step 2: Create `src/components/BottomNav.tsx`**

```typescript
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'

const tabs = [
  { href: '/dashboard', label: 'Inventory', icon: 'üì¶' },
  { href: '/add-item', label: 'Add Item', icon: '‚ûï' },
  { href: '/products', label: 'Products', icon: 'üóÇÔ∏è' },
]

export default function BottomNav() {
  const pathname = usePathname()
  return (
    <nav className="fixed bottom-0 left-0 right-0 bg-white border-t border-stone-200 flex">
      {tabs.map(tab => (
        <Link
          key={tab.href}
          href={tab.href}
          className={`flex-1 flex flex-col items-center py-3 text-xs gap-1 ${
            pathname === tab.href ? 'text-green-700 font-medium' : 'text-stone-500'
          }`}
        >
          <span className="text-xl">{tab.icon}</span>
          {tab.label}
        </Link>
      ))}
    </nav>
  )
}
```

**Step 3: Create `src/lib/inventory.ts`**

```typescript
import { prisma } from './db'
import { ItemStatus } from '@prisma/client'

export async function getInventoryByFarm(farmId: string) {
  return prisma.inventoryItem.findMany({
    where: { farmId },
    include: { productType: true },
    orderBy: { createdAt: 'desc' },
  })
}

export async function updateItemStatus(itemId: string, status: ItemStatus) {
  return prisma.inventoryItem.update({
    where: { id: itemId },
    data: { status },
  })
}
```

**Step 4: Create `src/app/(app)/dashboard/page.tsx`**

```typescript
import { createClient } from '@/lib/supabase/server'
import { getFarmByOwner } from '@/lib/farm'
import { getInventoryByFarm } from '@/lib/inventory'
import Link from 'next/link'

export default async function DashboardPage() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  const farm = await getFarmByOwner(user!.id)
  const items = await getInventoryByFarm(farm!.id)

  const available = items.filter(i => i.status === 'available')
  const sold = items.filter(i => i.status === 'sold')

  return (
    <main className="px-4 pt-6">
      <h1 className="text-xl font-bold text-stone-800 mb-1">{farm!.name}</h1>
      <div className="flex gap-3 mb-6">
        <div className="flex-1 bg-green-50 rounded-xl p-3 text-center">
          <p className="text-2xl font-bold text-green-700">{available.length}</p>
          <p className="text-xs text-green-600">Available</p>
        </div>
        <div className="flex-1 bg-stone-100 rounded-xl p-3 text-center">
          <p className="text-2xl font-bold text-stone-600">{sold.length}</p>
          <p className="text-xs text-stone-500">Sold</p>
        </div>
      </div>

      <div className="space-y-2">
        {items.map(item => (
          <Link
            key={item.id}
            href={`/dashboard/${item.id}`}
            className="flex items-center justify-between bg-white rounded-xl p-4 shadow-sm"
          >
            <div>
              <p className="font-medium text-stone-800">{item.productType.name}</p>
              <p className="text-sm text-stone-500">
                {item.weight ? `${item.weight} lbs ¬∑ ` : ''} ${Number(item.price).toFixed(2)}
              </p>
            </div>
            <span className={`text-xs px-2 py-1 rounded-full font-medium ${
              item.status === 'available'
                ? 'bg-green-100 text-green-700'
                : 'bg-stone-100 text-stone-500'
            }`}>
              {item.status}
            </span>
          </Link>
        ))}
        {items.length === 0 && (
          <p className="text-center text-stone-400 py-12">No items yet. Tap + to add one.</p>
        )}
      </div>
    </main>
  )
}
```

**Step 5: Manually test**

- Log in, complete onboarding
- Verify dashboard shows farm name, 0/0 counts, empty state message
- Verify bottom nav highlights correct tab

**Step 6: Commit**

```bash
git add -A
git commit -m "feat: add dashboard page with inventory list and bottom nav"
```

---

## Task 7: Product Types Management

**Files:**
- Create: `src/lib/products.ts`
- Create: `src/app/(app)/products/page.tsx`
- Create: `src/app/(app)/products/new/page.tsx`
- Create: `src/app/(app)/products/new/actions.ts`

**Step 1: Create `src/lib/products.ts`**

```typescript
import { prisma } from './db'
import { Category, PricingMode } from '@prisma/client'

export async function getProductsByFarm(farmId: string) {
  return prisma.productType.findMany({
    where: { farmId, archived: false },
    orderBy: { name: 'asc' },
  })
}

export async function createProduct(data: {
  farmId: string
  name: string
  category: Category
  pricingMode: PricingMode
  price: number
  unit: string
}) {
  return prisma.productType.create({ data })
}

export async function archiveProduct(id: string) {
  return prisma.productType.update({ where: { id }, data: { archived: true } })
}
```

**Step 2: Create `src/app/(app)/products/new/actions.ts`**

```typescript
'use server'

import { redirect } from 'next/navigation'
import { createClient } from '@/lib/supabase/server'
import { getFarmByOwner } from '@/lib/farm'
import { createProduct } from '@/lib/products'
import { Category, PricingMode } from '@prisma/client'

export async function addProduct(formData: FormData) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  const farm = await getFarmByOwner(user!.id)

  await createProduct({
    farmId: farm!.id,
    name: formData.get('name') as string,
    category: formData.get('category') as Category,
    pricingMode: formData.get('pricingMode') as PricingMode,
    price: parseFloat(formData.get('price') as string),
    unit: formData.get('unit') as string,
  })

  redirect('/products')
}
```

**Step 3: Create `src/app/(app)/products/new/page.tsx`**

```typescript
import { addProduct } from './actions'

const CATEGORIES = [
  'beef','pork','chicken','lamb','fish',
  'eggs','dairy','honey','preserves',
  'vegetables','fruit','other'
]

export default function NewProductPage() {
  return (
    <main className="px-4 pt-6">
      <h1 className="text-xl font-bold text-stone-800 mb-6">New product type</h1>
      <form className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-stone-700 mb-1">Name</label>
          <input name="name" type="text" placeholder="e.g. Ribeye Steak" required
            className="w-full px-3 py-2.5 border border-stone-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-600" />
        </div>
        <div>
          <label className="block text-sm font-medium text-stone-700 mb-1">Category</label>
          <select name="category" required
            className="w-full px-3 py-2.5 border border-stone-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-600 bg-white">
            {CATEGORIES.map(c => <option key={c} value={c}>{c.charAt(0).toUpperCase() + c.slice(1)}</option>)}
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium text-stone-700 mb-1">Pricing</label>
          <select name="pricingMode" required
            className="w-full px-3 py-2.5 border border-stone-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-600 bg-white">
            <option value="per_weight">Per weight ($/lb)</option>
            <option value="fixed">Fixed price</option>
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium text-stone-700 mb-1">Price ($)</label>
          <input name="price" type="number" step="0.01" min="0" placeholder="0.00" required
            className="w-full px-3 py-2.5 border border-stone-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-600" />
        </div>
        <div>
          <label className="block text-sm font-medium text-stone-700 mb-1">Unit</label>
          <input name="unit" type="text" placeholder="e.g. lbs, dozen, jar" required
            className="w-full px-3 py-2.5 border border-stone-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-600" />
        </div>
        <button formAction={addProduct}
          className="w-full py-3 bg-green-700 text-white font-medium rounded-lg hover:bg-green-800 transition-colors">
          Save product type
        </button>
      </form>
    </main>
  )
}
```

**Step 4: Create `src/app/(app)/products/page.tsx`**

```typescript
import { createClient } from '@/lib/supabase/server'
import { getFarmByOwner } from '@/lib/farm'
import { getProductsByFarm } from '@/lib/products'
import Link from 'next/link'

export default async function ProductsPage() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  const farm = await getFarmByOwner(user!.id)
  const products = await getProductsByFarm(farm!.id)

  return (
    <main className="px-4 pt-6">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-xl font-bold text-stone-800">Products</h1>
        <Link href="/products/new"
          className="px-4 py-2 bg-green-700 text-white text-sm font-medium rounded-lg">
          + New
        </Link>
      </div>
      <div className="space-y-2">
        {products.map(p => (
          <div key={p.id} className="bg-white rounded-xl p-4 shadow-sm">
            <p className="font-medium text-stone-800">{p.name}</p>
            <p className="text-sm text-stone-500">
              {p.category} ¬∑ {p.pricingMode === 'per_weight' ? `$${Number(p.price).toFixed(2)}/lb` : `$${Number(p.price).toFixed(2)} fixed`}
            </p>
          </div>
        ))}
        {products.length === 0 && (
          <p className="text-center text-stone-400 py-12">No products yet. Tap + New to add one.</p>
        )}
      </div>
    </main>
  )
}
```

**Step 5: Manually test**

- Navigate to `/products`
- Tap "+ New", fill in form, save
- Verify product appears in list

**Step 6: Commit**

```bash
git add -A
git commit -m "feat: add product type management (list + create)"
```

---

## Task 8: Add Item ‚Äî Core Workflow

**Files:**
- Create: `src/app/(app)/add-item/page.tsx`
- Create: `src/app/(app)/add-item/AddItemForm.tsx`
- Create: `src/app/(app)/add-item/actions.ts`

**Step 1: Create `src/app/(app)/add-item/actions.ts`**

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { getFarmByOwner } from '@/lib/farm'
import { prisma } from '@/lib/db'
import { calculatePrice } from '@/lib/pricing'

export async function createInventoryItem(formData: FormData) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  const farm = await getFarmByOwner(user!.id)

  const productTypeId = formData.get('productTypeId') as string
  const weightRaw = formData.get('weight') as string | null
  const weight = weightRaw ? parseFloat(weightRaw) : null

  const productType = await prisma.productType.findUnique({ where: { id: productTypeId } })
  if (!productType) throw new Error('Product type not found')

  const price = calculatePrice({
    pricingMode: productType.pricingMode as 'per_weight' | 'fixed',
    pricePerUnit: Number(productType.price),
    weight,
  })

  const item = await prisma.inventoryItem.create({
    data: {
      farmId: farm!.id,
      productTypeId,
      weight: weight ?? undefined,
      price,
      status: 'available',
    },
  })

  return { itemId: item.id, price, weight, productName: productType.name, farmName: farm!.name }
}
```

**Step 2: Create `src/app/(app)/add-item/AddItemForm.tsx`**

This is a client component ‚Äî it handles the interactive pricing preview and QR generation.

```typescript
'use client'

import { useState } from 'react'
import { createInventoryItem } from './actions'
import { calculatePrice } from '@/lib/pricing'
import { generateQRDataUrl } from '@/lib/qr'
import type { ProductType } from '@prisma/client'

type Props = { products: ProductType[] }

export default function AddItemForm({ products }: Props) {
  const [selectedId, setSelectedId] = useState('')
  const [weight, setWeight] = useState('')
  const [preview, setPreview] = useState<{ price: number; qrUrl: string; itemId: string } | null>(null)
  const [loading, setLoading] = useState(false)

  const selected = products.find(p => p.id === selectedId)

  const livePrice = selected
    ? (() => {
        try {
          return calculatePrice({
            pricingMode: selected.pricingMode as 'per_weight' | 'fixed',
            pricePerUnit: Number(selected.price),
            weight: weight ? parseFloat(weight) : null,
          })
        } catch { return null }
      })()
    : null

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    if (!selected) return
    setLoading(true)
    const fd = new FormData()
    fd.append('productTypeId', selectedId)
    if (weight) fd.append('weight', weight)
    const result = await createInventoryItem(fd)
    const qrUrl = await generateQRDataUrl(result.itemId, window.location.origin)
    setPreview({ price: result.price, qrUrl, itemId: result.itemId })
    setLoading(false)
  }

  async function handleShare() {
    if (!preview || !selected) return
    const canvas = document.getElementById('label-canvas') as HTMLCanvasElement
    canvas.toBlob(blob => {
      if (!blob) return
      const file = new File([blob], 'label.png', { type: 'image/png' })
      if (navigator.share) {
        navigator.share({ files: [file], title: selected.name })
      } else {
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = 'label.png'
        a.click()
      }
    })
  }

  if (preview && selected) {
    return (
      <div className="space-y-4">
        <div className="bg-white rounded-2xl p-6 shadow-sm text-center">
          <p className="text-sm text-stone-500 mb-1">{selected.name}</p>
          <p className="text-3xl font-bold text-stone-800 mb-1">${preview.price.toFixed(2)}</p>
          {weight && <p className="text-sm text-stone-500 mb-4">{weight} lbs</p>}
          <img src={preview.qrUrl} alt="QR code" className="mx-auto w-40 h-40" />
        </div>
        <button onClick={handleShare}
          className="w-full py-3 bg-green-700 text-white font-medium rounded-lg hover:bg-green-800 transition-colors">
          Share label
        </button>
        <button onClick={() => { setPreview(null); setWeight(''); setSelectedId('') }}
          className="w-full py-3 border border-stone-300 text-stone-700 font-medium rounded-lg">
          Add another item
        </button>
      </div>
    )
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label className="block text-sm font-medium text-stone-700 mb-1">Product type</label>
        <select
          value={selectedId}
          onChange={e => setSelectedId(e.target.value)}
          required
          className="w-full px-3 py-2.5 border border-stone-300 rounded-lg bg-white focus:outline-none focus:ring-2 focus:ring-green-600"
        >
          <option value="">Select a product‚Ä¶</option>
          {products.map(p => <option key={p.id} value={p.id}>{p.name}</option>)}
        </select>
      </div>

      {selected?.pricingMode === 'per_weight' && (
        <div>
          <label className="block text-sm font-medium text-stone-700 mb-1">Weight (lbs)</label>
          <input
            type="number" step="0.001" min="0"
            value={weight}
            onChange={e => setWeight(e.target.value)}
            placeholder="0.000"
            required
            className="w-full px-3 py-2.5 border border-stone-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-green-600"
          />
        </div>
      )}

      {livePrice !== null && (
        <div className="bg-green-50 rounded-xl p-4 text-center">
          <p className="text-sm text-green-600">Price</p>
          <p className="text-2xl font-bold text-green-700">${livePrice.toFixed(2)}</p>
        </div>
      )}

      <button
        type="submit"
        disabled={loading || !selected || (selected.pricingMode === 'per_weight' && !weight)}
        className="w-full py-3 bg-green-700 text-white font-medium rounded-lg hover:bg-green-800 disabled:opacity-40 transition-colors"
      >
        {loading ? 'Saving‚Ä¶' : 'Generate label'}
      </button>
    </form>
  )
}
```

**Step 3: Create `src/app/(app)/add-item/page.tsx`**

```typescript
import { createClient } from '@/lib/supabase/server'
import { getFarmByOwner } from '@/lib/farm'
import { getProductsByFarm } from '@/lib/products'
import AddItemForm from './AddItemForm'

export default async function AddItemPage() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  const farm = await getFarmByOwner(user!.id)
  const products = await getProductsByFarm(farm!.id)

  return (
    <main className="px-4 pt-6">
      <h1 className="text-xl font-bold text-stone-800 mb-6">Add item</h1>
      {products.length === 0 ? (
        <p className="text-stone-400 text-center py-12">
          No products yet. Go to Products to add some first.
        </p>
      ) : (
        <AddItemForm products={products} />
      )}
    </main>
  )
}
```

**Step 4: Manually test full workflow**

- Select a per_weight product ‚Üí enter weight ‚Üí verify live price updates
- Tap "Generate label" ‚Üí verify QR appears
- Tap "Share label" ‚Üí verify native share sheet opens (on phone) or download triggers (on desktop)
- Tap "Add another item" ‚Üí verify form resets
- Check `/dashboard` ‚Üí verify new item appears with correct price and status

**Step 5: Commit**

```bash
git add -A
git commit -m "feat: add item workflow with QR label generation and native share"
```

---

## Task 9: Item Detail Page (View QR + Mark as Sold)

**Files:**
- Create: `src/app/(app)/dashboard/[id]/page.tsx`
- Create: `src/app/(app)/dashboard/[id]/actions.ts`

**Step 1: Create `src/app/(app)/dashboard/[id]/actions.ts`**

```typescript
'use server'

import { revalidatePath } from 'next/cache'
import { updateItemStatus } from '@/lib/inventory'

export async function markAsSold(itemId: string) {
  await updateItemStatus(itemId, 'sold')
  revalidatePath('/dashboard')
}
```

**Step 2: Create `src/app/(app)/dashboard/[id]/page.tsx`**

```typescript
import { prisma } from '@/lib/db'
import { generateQRDataUrl } from '@/lib/qr'
import { notFound } from 'next/navigation'
import MarkSoldButton from './MarkSoldButton'

export default async function ItemDetailPage({ params }: { params: { id: string } }) {
  const item = await prisma.inventoryItem.findUnique({
    where: { id: params.id },
    include: { productType: true, farm: true },
  })
  if (!item) notFound()

  const qrUrl = await generateQRDataUrl(item.id, process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3000')

  return (
    <main className="px-4 pt-6">
      <h1 className="text-xl font-bold text-stone-800 mb-1">{item.productType.name}</h1>
      <p className="text-stone-500 text-sm mb-6">{item.farm.name}</p>

      <div className="bg-white rounded-2xl p-6 shadow-sm text-center mb-4">
        <img src={qrUrl} alt="QR code" className="mx-auto w-40 h-40 mb-4" />
        <p className="text-2xl font-bold text-stone-800">${Number(item.price).toFixed(2)}</p>
        {item.weight && <p className="text-sm text-stone-500">{Number(item.weight).toFixed(3)} lbs</p>}
        <span className={`inline-block mt-2 text-xs px-2 py-1 rounded-full font-medium ${
          item.status === 'available' ? 'bg-green-100 text-green-700' : 'bg-stone-100 text-stone-500'
        }`}>
          {item.status}
        </span>
      </div>

      {item.status === 'available' && <MarkSoldButton itemId={item.id} />}
    </main>
  )
}
```

**Step 3: Create `src/app/(app)/dashboard/[id]/MarkSoldButton.tsx`**

```typescript
'use client'

import { markAsSold } from './actions'

export default function MarkSoldButton({ itemId }: { itemId: string }) {
  return (
    <button
      onClick={() => markAsSold(itemId)}
      className="w-full py-3 border border-stone-300 text-stone-700 font-medium rounded-lg hover:bg-stone-100 transition-colors"
    >
      Mark as sold
    </button>
  )
}
```

**Step 4: Add `NEXT_PUBLIC_APP_URL` to `.env.local`**

```
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

**Step 5: Manually test**

- From dashboard, tap an item
- Verify item detail shows QR code and correct price
- Tap "Mark as sold" ‚Üí verify status updates to sold
- Navigate back to dashboard ‚Üí verify status badge updated

**Step 6: Commit**

```bash
git add -A
git commit -m "feat: add item detail page with QR view and mark-as-sold"
```

---

## Task 10: Deploy to Vercel

**Files:**
- Modify: `.env.local` (add production values)

**Step 1: Push code to GitHub**

```bash
git remote add origin https://github.com/YOUR_USERNAME/digital-herdsman.git
git push -u origin main
```

**Step 2: Import project in Vercel**

- Go to vercel.com ‚Üí New Project ‚Üí import your repo
- Add environment variables:
  - `NEXT_PUBLIC_SUPABASE_URL`
  - `NEXT_PUBLIC_SUPABASE_ANON_KEY`
  - `DATABASE_URL`
  - `DIRECT_URL`
  - `NEXT_PUBLIC_APP_URL` (set to your Vercel URL)

**Step 3: Deploy**

Vercel auto-deploys on push. Verify:
- Login works on mobile
- Full add-item workflow works end to end
- Dashboard updates in real time

---

## Summary

| Task | Deliverable |
|------|------------|
| 1 | Next.js project scaffolded |
| 2 | Supabase + Prisma schema live |
| 3 | Pricing + QR lib with tests |
| 4 | Login page |
| 5 | Farm onboarding |
| 6 | Dashboard + bottom nav |
| 7 | Product type management |
| 8 | Add item + QR label + share |
| 9 | Item detail + mark as sold |
| 10 | Deployed to Vercel |
